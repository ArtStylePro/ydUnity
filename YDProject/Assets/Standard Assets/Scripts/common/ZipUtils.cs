// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.IO;
using ICSharpCode.SharpZipLib.Zip;
using ICSharpCode.SharpZipLib.Core;
using UnityEngine;
namespace AssemblyCSharpfirstpass
{
	public class ZipUtils
	{
		public ZipUtils ()
		{
		}
		public static bool unzipMusicZip(byte[] _data,string _path)
		{
			using(MemoryStream ms = new MemoryStream(_data,false))
			{
				//GZipStream zip = new GZipStream(ms,CompressionMode.Decompress);
			
				ZipInputStream zipInputStream = new ZipInputStream(ms);
				ZipEntry zipEntry = zipInputStream.GetNextEntry();
				while (zipEntry != null) {
					String entryFileName = zipEntry.Name;
					// to remove the folder from the entry:- entryFileName = Path.GetFileName(entryFileName);
					// Optionally match entrynames against a selection list here to skip as desired.
					// The unpacked length is available in the zipEntry.Size property.

					byte[] buffer = new byte[4096];     // 4K is optimum

					// Manipulate the output filename here as desired.
					String fullZipToPath = Path.Combine(_path, entryFileName);
					string directoryName = Path.GetDirectoryName(fullZipToPath);
					if (directoryName.Length > 0)
						Directory.CreateDirectory(directoryName);
					Debug.Log ("unzip:" + fullZipToPath);
					
					// Unzip file in buffered chunks. This is just as fast as unpacking to a buffer the full size
					// of the file, but does not waste memory.
					// The "using" will close the stream even if an exception occurs.
					using (FileStream streamWriter = File.Create(fullZipToPath)) {
						StreamUtils.Copy(zipInputStream, streamWriter, buffer);
					}
					zipEntry = zipInputStream.GetNextEntry();
				}
				ms.Close();

			}
			return true;
		}

	}
}

